#!/usr/bin/env python
# 
# Runs a series of IOR tests for a given IOR script
#
# Copyright: CSIRO 2017
# Author: Paulus Lahur <paulus.lahur@csiro.au>
#----------------------------------------------------------------------|

import subprocess
import re

# TODO: Set the followings using arguments instead of hardcoding

# Set true to use SLURM to submit jobs
use_slurm = False

# Set true if simulating tMSSink test
simulate_tmssink = True
if (simulate_tmssink):
    # The number of measurement set to simulate
    nsets = 1

# Set true if simulating IO of multiple files
concurrent = True

#----------------------------------------------------------------------|
#
# Read IOR input file (extended format) and record all useful lines
# (ie. non-empty and non-comment)

input_lines = list()
with (open('IOR_test_input.txt', 'r')) as IOR_input_script:
    for line in IOR_input_script.readlines():
        # Clean line from leading white characters
        clean_line = line.lstrip()
        # Record the line if it is not a comment
        if (clean_line[0] != '#'):
            input_lines.append(clean_line)
            #print clean_line

#print len(input_lines)
IOR_input_script.close()

# TODO: Check the validity of the file by checking the existence of 
# keywords: IOR START, RUN, IOR STOP

# count the number of IOR files to output by counting the number of 
# parameter values inside this brackets: []

ntest = 0
nparam = 0
param_list = list()
for line in input_lines:
    # If the line contains a range of values indicated by bracket [],
    # this is the parameter to vary
    if (line.find('[') >= 0):
        param = line[0:line.find('=')]
        param = param.strip()
        param_list.append(param)
        print param

        values_string = line[line.find('[')+1:line.find(']')]
        values = values_string.split(',')
        nparam += 1

        for index, value in enumerate(values):
            values[index] = values[index].strip()
            # If the number of tests is not yet known, set it
            if (ntest == 0):
                ntest = len(values)
            # Else if the number of tests is found to be different
            elif (ntest > 0):
                if (ntest != len(values)):
                    print "ERROR: disagreement in the number of tests"
                    SystemExit

        print values
        if (nparam == 1):
            values_zero = values

print "The number of tests: " + str(ntest)
print "The number of parameters to vary: " + str(nparam)

# TODO: Handle the case where the list of tests is empty
#       (ie. there is only 1 IOR test)

# Prepare the subdirectories for output files
output = subprocess.check_output('mkdir -p ' + 'script', shell=True)
output = subprocess.check_output('mkdir -p ' + 'batch', shell=True)
output = subprocess.check_output('mkdir -p ' + 'log', shell=True)

# TODO: Check the existence of target directory for measurement.
# If one is not found, report error

base_name = 'IOR_test'

# Make IOR files for specific test cases
test_name_list = list()
for index in range(len(values_zero)):
    #test_name = (base_name + '_' + param_list[0] + '_' + 
    #        str(values_zero[index]))
    test_name = base_name + '_' + param_list[0] + '_' + str(index)
    test_name_list.append(test_name)
    IOR_script_name = 'script/' + test_name + '.txt'
    print 'IOR script: ' + IOR_script_name
    file = open(IOR_script_name, 'w')
    file.write('# IOR script file\n')
    file.write('# This file is automatically generated\n')

    for line in input_lines:
        # If the parameter values are in bracket, select one
        if (line.find('[') >= 0):
            param = line[0:line.find('=')]
            param = param.strip()
            values_string = line[line.find('[')+1:line.find(']')]
            values = values_string.split(',')
            value = values[index].strip()
            file.write('\t' + param + '=' + value + '\n')
        else:
            # Simply copy the content
            if ((line != 'IOR START\n') and (line != 'IOR STOP\n') and
                (line != 'RUN\n')):
                file.write('\t')
            file.write(line)

    file.close()

if (use_slurm):
    print 'Running using SLURM'

    if (simulate_tmssink):
        # This is to simulate many small files in measurement set
        # The number of measurement set to simulate
        #nsets = 8
        # The number of simulated files per set (this is fixed)
        nsimulated_files_per_set = 64
        # The total numberof simulated files
        nsimulated_files = nsets * nsimulated_files_per_set
        # The number of tasks per computational node (hardware limit)
        ntasks_per_node = 16
        # The number of computational nodes
        nnodes = nsimulated_files / ntasks_per_node
    else:
        # NORMAL MODE: 1 big file
        nnodes = 1
        nsimulated_files = 1
    
    job_id = 0
    for test_name in test_name_list:
        prev_job_id = job_id

        script_name = 'script/' + test_name + '.txt'
        batch_name = 'batch/' + test_name + '.sbatch'
        log_name = 'log/' + test_name + '.log'

        file = open(batch_name, 'w')
        file.write('#!/bin/bash -l\n')
        file.write('#SBATCH --job-name=' + test_name + '\n')
        file.write('#SBATCH --account=askap\n')
        file.write('#SBATCH --time=1:00:00\n')
        file.write('#SBATCH --nodes=' + str(nnodes) + '\n')
        file.write('#SBATCH --ntasks=' + str(nsimulated_files) + '\n')
        file.write('#SBATCH --export=NONE\n\n')
        file.write('##############################################\n')
        file.write('# IOR batch file for SLURM.\n')
        file.write('# This file is automatically generated.\n')
        file.write('##############################################\n\n')
        file.write('# Module management for IOR\n')
        file.write('module unload PrgEnv-cray\n')
        file.write('module unload gcc\n')
        file.write('module load PrgEnv-gnu\n')
        file.write('module load gcc\n')
        file.write('module load ior\n\n')
        
        file.write('srun -n ' + str(nsimulated_files) + ' ior -f "./' + script_name + '" &> "' + 
                log_name + '"\n')
        file.close()

        print("Submitting SLURM job")
        if (concurrent):
            # Execute jobs concurrently
            output = subprocess.check_output('sbatch ' + batch_name, shell=True)
        else:
            # Execute jobs in sequence
            # If this is the first job
            if (prev_job_id == 0):
                output = subprocess.check_output('sbatch ' + batch_name, shell=True)
            # Else if there is a previous job, this job must wait after its completion
            elif (prev_job_id > 0):
                output = subprocess.check_output('sbatch --dependency=afterany:' + 
                        prev_job_id + " " + batch_name, shell=True)
            else:
                print("ERROR: illegal previous job ID: " + prev_job_id)

        print output
        # The third word of the output is job ID
        job_id = output.split()[3]
        #print('Current job ID: ' + jobId)

else:
    print 'Running without using SLURM'
    #subprocess.check_output('module unload PrgEnv-cray', shell=True)
    #subprocess.check_output('module unload gcc', shell=True)
    #subprocess.check_output('module load PrgEnv-gnu', shell=True)
    #subprocess.check_output('module load gcc', shell=True)
    output = subprocess.check_output('module list; module load mpich; module load ior', shell=True)
    print "Modules are loaded"
    for test_name in test_name_list:
        script_name = 'script/' + test_name + '.txt'
        log_name = 'log/' + test_name + '.log'
        output = subprocess.check_output('ior -f ./' + script_name + ' &> ' + log_name, shell=True)
        print output

