#!/usr/bin/env python
# @file
# Build debian packages
#
# @copyright (c) 2013 CSIRO
# Australia Telescope National Facility (ATNF)
# Commonwealth Scientific and Industrial Research Organisation (CSIRO)
# PO Box 76, Epping NSW 1710, Australia
# atnf-enquiries@csiro.au
#
# This file is part of the ASKAP software distribution.
#
# The ASKAP software distribution is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the License
# or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.
#
# @author Malte Marquarding <Malte.Marquarding@csiro.au>
#
from __future__ import print_function
import collections
import os
import sys
import glob
import subprocess
import optparse
import shutil

import re
import stat

from askapdev.rbuild.dependencies import Dependency
from askapdev.rbuild import utils

rev_file = ".last_svnrev"


def get_package_revision(pth):
    cmd = "svn info %s |grep Rev: |awk '{print $NF}'" % pth
    out = utils.runcmd(cmd, shell=True)
    if out[-1] != 0 or len(out[0]) == 0:
        raise OSError(out[1])
    return str(out[0].strip())


def get_rev(revfile):
    rev = get_package_revision(".")
    with open(revfile, "w") as of:
        of.write("{0}\n".format(rev))
    return rev


def needs_rebuild(pkg):
    revfile = os.path.join(pkg, rev_file)
    if not os.path.exists(revfile):
        newrev = get_rev(revfile)
        return True
    rev = open(revfile, 'r').read().strip()
    newrev = get_rev(revfile)
    return rev != newrev


def add_shlibs_mapping():
    shlibs = glob.glob("debian/*/DEBIAN/shlibs")
    if not shlibs:
        return
    if len(shlibs) > 1:
        print("warn: More than one debian package found. Using only first one")
    shutil.copyfile(shlibs[0], ".shlibs")


def get_shlibs(paths):
    all_shlibs = []
    for p in paths:
        sh_file = os.path.join(p, ".shlibs")
        if os.path.exists(sh_file):
            content = open(sh_file).read().strip()
            all_shlibs.append(content)
    sh_local = os.path.join("debian", "shlibs.local")
    if not all_shlibs:
        return
    with open(sh_local, "w") as of:
        of.write("\n".join(all_shlibs))


def add_pydist_overrides(dep_keys):
    pydists = []
    rx = r"\[(.+)\]$"
    rx2 = r"\[.+\]$"
    for pkg in dep_keys:
        if pkg.startswith("python-"):
            pypkg = pkg.replace("python-", "")
            pkgname = re.findall(rx, pypkg)
            if pkgname:
                pypkg = pkgname[0]
            debname = re.sub(rx2, "", pkg)
            pydists.append("{} {}".format(pypkg, debname))
    if not pydists:
        return
    with open("debian/pydist-overrides", "w") as of:
        of.write("\n".join(pydists) + "\n")


def package(pkg, outdir, force=False):
    """Create a debian package.
    """
    cdir = os.path.abspath(os.curdir)
    try:
        pkg = os.path.normpath(pkg)
        #check_built(pkg)
        rpkg = os.path.relpath(pkg, os.environ["ASKAP_ROOT"])
        os.chdir(pkg)
        dep = Dependency()
        dep.add_package()
        get_shlibs(dep.get_rootdirs())
        add_pydist_overrides(dep.keys(explicit=True))
        # use dependency keys for local java debian packages
        jpkgs = [(k, dep.get_dep_path(k)) for k in dep.keys() if "java" in k]
        jnames = [n for n, p in jpkgs if not p.startswith("/")]
        if jnames:
            with open(os.path.join("debian", "askap.dependencies"), "w") as sf:
                 sf.write("local:Depends={0}\n".format(", ".join(jnames)))
        libdirs = dep.get_librarydirs()
        if libdirs:
            with open(os.path.join("debian", "askap.ldpath"), "w") as sf:
                sf.write("-l"+":".join(libdirs))
        # run in a clean, non-ASKAPsoft env
        if not force:
            if not needs_rebuild(pkg):
                print("info: Package {0} up-to-date".format(rpkg))
                return

        print("info: Creating debian package for '{0}'"
              .format(rpkg))

        # have to enter unpacked source to package (debian symlink into it
        # is created by the builder). Assumption source dir is (*).tar.gz
        native = False
        if "3rdParty" in pkg:
            rules = open("debian/rules").read()
            if os.path.exists("DEBIAN_NATIVE") or "pybuild" in rules:
                sdir = None
                for suffix in [".tar.gz", ".tar.bz2", ".tgz", ".zip"]:
                    pkg = glob.glob("*"+suffix)
                    if pkg:
                        sdir = pkg[0].replace(suffix, "")
                if sdir is None or not os.path.exists(sdir):
                    raise OSError(
                        "Source directory '{}' doesn't exist".format(sdir))
                tgt = os.path.join(sdir, "debian")
                native = True
                if not os.path.exists(tgt):
                    os.symlink("../debian", tgt)
                os.chdir(sdir)
        try:
            subprocess.check_call(
                "dpkg-buildpackage -uc -b > debpackage.log 2>&1",
                shell=True,
                env={'PATH': "/usr/bin:/usr/sbin:/bin:/sbin",
                     'HOME': os.environ["HOME"]},
                )
            if native:
                os.chdir("..")
            add_shlibs_mapping()
        except:
            sys.stdout.flush()
            print(open('debpackage.log', 'r').read(), file=sys.stderr)
            sys.exit(1)
        if os.path.exists('debpackage.log'):
            os.remove('debpackage.log')
        if outdir:
            glob_str = "*.deb"
            if not native:
                glob_str = "/".join(("..", glob_str))
            debs = glob.glob(glob_str)
            if not debs:
                print("No debs found. Did packaging fail?", file=sys.stderr)
                if os.path.exists(rev_file):
                    os.remove(rev_file)
                sys.exit(1)
            for d in debs:
                utils.q_print('info: Moving {0} to {1}'.format(d, outdir))
                outname = os.path.join(outdir, os.path.basename(d))
                if os.path.exists(outname):
                    os.remove(outname)
                shutil.move(d, outdir)
                st = os.stat(outname)
                os.chmod(outname, st.st_mode | stat.S_IWGRP)
        else:
            utils.q_print("info: debian artifacts are available in "
                          "the parent directory")
        chg = glob.glob('../*.changes')
        for c in chg:
            os.remove(c)
    except:
        print("error: Packaging '{}' failed".format(pkg), file=sys.stderr)
        if os.path.exists(rev_file):
            os.remove(rev_file)
        raise
    finally:
        os.chdir(cdir)


def check_built(pkgdir):
    if not os.path.exists(os.path.join(pkgdir, "install")):
        print("Package {0} not built. Run rbuild -t install first".format(
            pkgdir), file=sys.stderr)
        sys.exit(1)


USAGE_MSG = 'usage: %prog [options] [<package_path>]'
DESC_MSG = '''This program builds debian packages for the specified and 
optionally all its dependencies.'''
PARSER = optparse.OptionParser(usage=USAGE_MSG, description=DESC_MSG)
# Boolean.
PARSER.add_option('-r', '--recursive', dest='recursive', action='store_true',
                  help='Build debian packages for this package and all its dependencies')
PARSER.add_option('-f', '--force', dest='force', action='store_true',
                  help='Force creation of debian packages')
PARSER.add_option('-q', '--quiet', dest='quite', action='store_true',
                  help='silence build')
PARSER.add_option('-o', '--outdir', dest='outdir',
                  help='The optional directory to put all debian packages '
                  'into. Default is parent dir.')
PARSER.set_defaults(outdir='')

if __name__ == "__main__":
    if utils.get_platform()['distribution'] != 'debian':
        print("error: Only usable on debian systems", file=sys.stderr)
        sys.exit(1)
    (opts, args) = PARSER.parse_args()
    if opts.outdir:
        if not os.path.exists(opts.outdir):
            raise IOError("Output directory '{0}' not found")
    tgt = len(args) and args[0] or os.curdir
    myself = os.path.abspath(tgt)
    dep = Dependency()
    dep.add_package(None, myself)
    a_root = os.environ["ASKAP_ROOT"]
    extradeps = [
        os.path.join(a_root, "Debian/packages/tos-site-config/current"),
        os.path.join(a_root,"Debian/packages/tos-ice-config/current"),
        os.path.join(a_root,"Debian/packages/tos-epics-config/current"),
    ]
    if opts.recursive:
        deps = dep.get_rootdirs()
        deps.reverse()
        deppkgs = \
            extradeps + list(collections.OrderedDict.fromkeys(deps)) + [myself]
        for pkgdir in deppkgs:
            is_external_dir = pkgdir.startswith("/") and a_root not in pkgdir
            if os.path.exists(os.path.join(pkgdir, "NO_DEBIAN")) \
                    or is_external_dir:
                continue
            package(os.path.normpath(pkgdir), opts.outdir, opts.force)
    else:
        package(myself, opts.outdir, opts.force)
