/// ----------------------------------------------------------------------------
/// This file is generated by schema_definitions/generate.py.
/// Do not edit directly or your changes will be lost!
/// ----------------------------------------------------------------------------
///
/// @copyright (c) 2016 CSIRO
/// Australia Telescope National Facility (ATNF)
/// Commonwealth Scientific and Industrial Research Organisation (CSIRO)
/// PO Box 76, Epping NSW 1710, Australia
/// atnf-enquiries@csiro.au
///
/// This file is part of the ASKAP software distribution.
///
/// The ASKAP software distribution is free software: you can redistribute it
/// and/or modify it under the terms of the GNU General Public License as
/// published by the Free Software Foundation; either version 2 of the License,
/// or (at your option) any later version.
///
/// This program is distributed in the hope that it will be useful,
/// but WITHOUT ANY WARRANTY; without even the implied warranty of
/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
/// GNU General Public License for more details.
///
/// You should have received a copy of the GNU General Public License
/// along with this program; if not, write to the Free Software
/// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
///
/// @author Daniel Collins <daniel.collins@csiro.au>

#pragma once

// System includes
#include <string>
#include <vector>
#include <boost/cstdint.hpp>
#include <boost/shared_ptr.hpp>

// ASKAPsoft includes
#include <askap/AskapError.h>
#include <askap/AskapLogging.h>

// Ice interfaces
#include <SkyModelService.h>
#include <SkyModelServiceDTO.h>

// Local package includes
#include "datamodel/ContinuumComponent.h"
#include "SmsTypes.h"

namespace askap {
namespace cp {
namespace sms {

// Alias for the Ice type namespace
namespace ice_interfaces = askap::interfaces::skymodelservice;

/// @brief Transfers data from the datamodel::ContinuumComponent class to the
/// Ice DTO class. If present, polarisation data will be added to the optional
/// polarisation member of ContinuumComponent.
///
/// @param[in] components Pointer to a vector of components for transfer.
/// @throw AskapError Thrown if there are errors.
/// @return askap::interfaces::skymodelservice::ComponentSeq
ice_interfaces::ComponentSeq marshallComponentsToDTO(
    boost::shared_ptr< std::vector<datamodel::ContinuumComponent> > components)
{
    // preallocate space for more efficient allocation
    ice_interfaces::ComponentSeq dst(components->size());

    int i = 0;
    for (std::vector<datamodel::ContinuumComponent>::const_iterator it = components->begin();
        it != components->end();
        it++, i++) {

        // Copy the component data
        dst[i].id = it->continuum_component_id;
        dst[i].componentId = it->component_id;
        dst[i].ra = it->ra;
        dst[i].dec = it->dec;
        dst[i].raErr = it->ra_err;
        dst[i].decErr = it->dec_err;
        dst[i].freq = it->freq;
        dst[i].fluxPeak = it->flux_peak;
        dst[i].fluxPeakErr = it->flux_peak_err;
        dst[i].fluxInt = it->flux_int;
        dst[i].fluxIntErr = it->flux_int_err;
        dst[i].majAxis = it->maj_axis;
        dst[i].minAxis = it->min_axis;
        dst[i].posAng = it->pos_ang;
        dst[i].majAxisErr = it->maj_axis_err;
        dst[i].minAxisErr = it->min_axis_err;
        dst[i].majAxisDeconv = it->maj_axis_deconv;
        dst[i].minAxisDeconv = it->min_axis_deconv;
        dst[i].posAngDeconv = it->pos_ang_deconv;
        dst[i].spectralIndex = it->spectral_index;
        dst[i].spectralCurvature = it->spectral_curvature;
        dst[i].majAxisDeconvErr = it->maj_axis_deconv_err;
        dst[i].minAxisDeconvErr = it->min_axis_deconv_err;
        dst[i].posAngDeconvErr = it->pos_ang_deconv_err;
        dst[i].spectralIndexErr = it->spectral_index_err;
        dst[i].spectralIndexFromTt = it->spectral_index_from_TT;

        // polarisation may not be present
        if (it->polarisation.get()) {
            const datamodel::Polarisation* src_pol = it->polarisation.get();

            ice_interfaces::ContinuumComponentPolarisation dst_pol;

            dst_pol.lambdaRefSq = src_pol->lambda_ref_sq;
            dst_pol.polPeakFit = src_pol->pol_peak_fit;
            dst_pol.polPeakFitDebias = src_pol->pol_peak_fit_debias;
            dst_pol.polPeakFitErr = src_pol->pol_peak_fit_err;
            dst_pol.polPeakFitSnr = src_pol->pol_peak_fit_snr;
            dst_pol.polPeakFitSnrErr = src_pol->pol_peak_fit_snr_err;
            dst_pol.fdPeakFit = src_pol->fd_peak_fit;
            dst_pol.fdPeakFitErr = src_pol->fd_peak_fit_err;

            dst[i].polarisation.push_back(dst_pol);
        } // end of polarisation branch
    } // end of component loop


    return dst;
}


}
}
}
