/// ----------------------------------------------------------------------------
/// This file is generated by schema_definitions/generate.py.
/// Do not edit directly or your changes will be lost!
/// ----------------------------------------------------------------------------
///
/// @copyright (c) 2016 CSIRO
/// Australia Telescope National Facility (ATNF)
/// Commonwealth Scientific and Industrial Research Organisation (CSIRO)
/// PO Box 76, Epping NSW 1710, Australia
/// atnf-enquiries@csiro.au
///
/// This file is part of the ASKAP software distribution.
///
/// The ASKAP software distribution is free software: you can redistribute it
/// and/or modify it under the terms of the GNU General Public License as
/// published by the Free Software Foundation; either version 2 of the License,
/// or (at your option) any later version.
///
/// This program is distributed in the hope that it will be useful,
/// but WITHOUT ANY WARRANTY; without even the implied warranty of
/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
/// GNU General Public License for more details.
///
/// You should have received a copy of the GNU General Public License
/// along with this program; if not, write to the Free Software
/// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
///
/// @author Daniel Collins <daniel.collins@csiro.au>

#pragma once

// System includes
#include <string>
#include <vector>
#include <boost/cstdint.hpp>
#include <boost/shared_ptr.hpp>

// ASKAPsoft includes
#include <askap/AskapError.h>
#include <askap/AskapLogging.h>

// Ice interfaces
#include <SkyModelService.h>
#include <SkyModelServiceDTO.h>

// Local package includes
#include "datamodel/ContinuumComponent.h"
#include "SmsTypes.h"

namespace askap {
namespace cp {
namespace sms {

// Alias for the Ice type namespace
namespace ice_interfaces = askap::interfaces::skymodelservice;

/// @brief Transfers data from the datamodel::ContinuumComponent class to the
/// Ice DTO class. If present, polarisation data will be added to the optional
/// polarisation member of ContinuumComponent.
///
/// @param[in] components Pointer to a vector of components for transfer.
/// @throw AskapError Thrown if there are errors.
/// @return askap::interfaces::skymodelservice::ComponentSeq
ice_interfaces::ComponentSeq marshallComponentsToDTO(
    boost::shared_ptr< std::vector<datamodel::ContinuumComponent> > components)
{
    // This might be nice if I can define a conversion operator from
    // datamodel::ContinuumComponent to ice_interfaces::ContinuumComponent
    // But unfortunately, both source and destination classes are produced by
    // the corresponding systems (Ice slice compiler, ODB class generation),
    // so I have no easy way to define the conversion. Doing it manually isn't
    // too bad though due to the code generation.
    //return ice_interfaces::ComponentSeq(components->begin(), components->end());

    // preallocate space for more efficient allocation
    ice_interfaces::ComponentSeq dst(components->size());

    int i = 0;
    for (std::vector<datamodel::ContinuumComponent>::const_iterator it = components->begin();
        it != components->end();
        it++, i++) {

        // Copy the component data
        dst[i].componentId = it->component_id;
        dst[i].ra = it->ra;
        dst[i].dec = it->dec;
        dst[i].raErr = it->ra_err;
        dst[i].decErr = it->dec_err;
        dst[i].freq = it->freq;
        dst[i].fluxPeak = it->flux_peak;
        dst[i].fluxPeakErr = it->flux_peak_err;
        dst[i].fluxInt = it->flux_int;
        dst[i].fluxIntErr = it->flux_int_err;
        dst[i].spectralIndex = it->spectral_index;
        dst[i].spectralCurvature = it->spectral_curvature;

        // polarisation may not be present
        if (it->polarisation.get()) {
            const datamodel::Polarisation* src_pol = it->polarisation.get();

            // I need to profile how the performance of stack instance followed
            // by assignment to the vector compares to the resize and assign
            // members in place. On the surface, it is comparing a default ctor, field assignment, and copy ctor
            // to default ctor and field assignment. I hope to avoid the additional
            // copy when pushing the stack instance into the vectory.
            // Of course, the compiler could be doing all sorts of optimisations, so
            // sticking to the clearer code is probably best.
            ice_interfaces::ContinuumComponentPolarisation dst_pol;

            // Or:
            //dst[i].polarisation.resize(1);
            // And then:
            //dst[i].polarisation[0].polPeakFit = src_pol->pol_peak_fit;

            dst_pol.lambdaRefSq = src_pol->lambda_ref_sq;
            dst_pol.polPeakFit = src_pol->pol_peak_fit;
            dst_pol.polPeakFitDebias = src_pol->pol_peak_fit_debias;
            dst_pol.polPeakFitErr = src_pol->pol_peak_fit_err;
            dst_pol.polPeakFitSnr = src_pol->pol_peak_fit_snr;
            dst_pol.polPeakFitSnrErr = src_pol->pol_peak_fit_snr_err;
            dst_pol.fdPeakFit = src_pol->fd_peak_fit;
            dst_pol.fdPeakFitErr = src_pol->fd_peak_fit_err;

            // Assign our stack variable to the vector. Hopefully the additional
            // copy constructor gets optimised away.
            dst[i].polarisation.push_back(dst_pol);
        } // end of polarisation branch
    } // end of component loop


    return dst;
}


}
}
}
