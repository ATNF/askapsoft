// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#include <odb/pre.hxx>

#define ODB_MYSQL_QUERY_COLUMNS_DEF
#include "ComponentStats-odb-mysql.h"
#undef ODB_MYSQL_QUERY_COLUMNS_DEF

#include <cassert>
#include <cstring>  // std::memcpy

#include <odb/schema-catalog-impl.hxx>
#include <odb/function-table.hxx>

#include <odb/mysql/traits.hxx>
#include <odb/mysql/database.hxx>
#include <odb/mysql/transaction.hxx>
#include <odb/mysql/connection.hxx>
#include <odb/mysql/statement.hxx>
#include <odb/mysql/statement-cache.hxx>
#include <odb/mysql/view-statements.hxx>
#include <odb/mysql/container-statements.hxx>
#include <odb/mysql/exceptions.hxx>
#include <odb/mysql/view-result.hxx>
#include <odb/mysql/enum.hxx>

namespace odb
{
  // ComponentStats
  //

  bool access::view_traits_impl< ::askap::cp::sms::datamodel::ComponentStats, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // count
    //
    t[0UL] = 0;

    return grew;
  }

  void access::view_traits_impl< ::askap::cp::sms::datamodel::ComponentStats, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i)
  {
    using namespace mysql;

    mysql::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // count
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.count_value;
    b[n].is_null = &i.count_null;
    n++;
  }

  void access::view_traits_impl< ::askap::cp::sms::datamodel::ComponentStats, id_mysql >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // count
    //
    {
      ::std::size_t& v =
        o.count;

      mysql::value_traits<
          ::std::size_t,
          mysql::id_ulonglong >::set_value (
        v,
        i.count_value,
        i.count_null);
    }
  }

  access::view_traits_impl< ::askap::cp::sms::datamodel::ComponentStats, id_mysql >::query_base_type
  access::view_traits_impl< ::askap::cp::sms::datamodel::ComponentStats, id_mysql >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "count(`ContinuumComponent`.`continuum_component_id`) ");

    r += "FROM `ContinuumComponent`";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::askap::cp::sms::datamodel::ComponentStats, id_mysql >::view_type >
  access::view_traits_impl< ::askap::cp::sms::datamodel::ComponentStats, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) mysql::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  result< access::view_traits_impl< ::askap::cp::sms::datamodel::ComponentStats, id_mysql >::view_type >
  access::view_traits_impl< ::askap::cp::sms::datamodel::ComponentStats, id_mysql >::
  query (database& db, const odb::query_base& q)
  {
    return query (db, query_base_type (q));
  }

  static const
  access::view_traits_impl< ::askap::cp::sms::datamodel::ComponentStats, id_common >::
  function_table_type function_table_askap_cp_sms_datamodel_ComponentStats_ =
  {
    &access::view_traits_impl< ::askap::cp::sms::datamodel::ComponentStats, id_mysql >::query
  };

  static const view_function_table_entry< ::askap::cp::sms::datamodel::ComponentStats, id_mysql >
  function_table_entry_askap_cp_sms_datamodel_ComponentStats_ (
    &function_table_askap_cp_sms_datamodel_ComponentStats_);
}

namespace odb
{
  static bool
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          return true;
        }
        case 2:
        {
          db.execute ("CREATE TABLE IF NOT EXISTS `schema_version` (\n"
                      "  `name` VARCHAR(255) NOT NULL PRIMARY KEY,\n"
                      "  `version` BIGINT UNSIGNED NOT NULL,\n"
                      "  `migration` TINYINT(1) NOT NULL)\n"
                      " ENGINE=InnoDB");
          db.execute ("DELETE FROM `schema_version`\n"
                      "  WHERE `name` = ''");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          return true;
        }
        case 2:
        {
          db.execute ("CREATE TABLE IF NOT EXISTS `schema_version` (\n"
                      "  `name` VARCHAR(255) NOT NULL PRIMARY KEY,\n"
                      "  `version` BIGINT UNSIGNED NOT NULL,\n"
                      "  `migration` TINYINT(1) NOT NULL)\n"
                      " ENGINE=InnoDB");
          db.execute ("INSERT IGNORE INTO `schema_version` (\n"
                      "  `name`, `version`, `migration`)\n"
                      "  VALUES ('', 1, 0)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_create_entry
  create_schema_entry_ (
    id_mysql,
    "",
    &create_schema);

  static const schema_catalog_migrate_entry
  migrate_schema_entry_1_ (
    id_mysql,
    "",
    1ULL,
    0);
}

#include <odb/post.hxx>
